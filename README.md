# React / Redux / Typescript / REST Template

Project template for React projects which interact with RESTful APIs. The template includes basic setup for Webpack, TypeScript and Redux. There are also some helper functions to reduce boilerplate code to minimum. Hot reload is enabled in development mode.

This template should handle most average sized and also larger React projects. There are only a few dependencies and the resulting bundle size is quite small. You can throw your favorite UI framework and / or CSS-in-JS solution to the mix.

## Getting started

Local development environment can be started with:

1. Fork, copy or clone this repo
2. Run `npm install`
3. Run `npm start`

A basic example should start at http://localhost:3000.

## Configs and bundling

Webpack configurations can be found from the `webpack.*` files in the root of the project. There is a common config which is merged either with development config (local development) or with production config (other environments).

You can define environment related variables in the `config.json` file. Environment specific API urls are defined there.

Babel is configured via the `.babelrc` file.

Typescript config and linter configs are in the `tsconfig.json` and `.eslintrc.js` files.

Prettier config is in `.prettierrc.js` file.

Test / production builds:

- Development: `npm run build:dev`
- QA: `npm run build:qa`
- Production: `npm run build:prod`

The difference between these builds is currently only the API endpoint defined in `config.json`. Webpack will override configuration values in the code with the values defined in `config.json` during the build process.

## Template structure

```
src
 ├── index.tsx                 -> Entry point of the app
 ├── declarations.d.ts         -> Global TS declarations
 ├─> api                       -> API related utilities
 │   └── index.ts              -> Simple fetch wrapper functions for API calls
 ├─> app                       -> High level components & configs
 │   ├── App.tsx               -> Main component, renders Routes
 │   ├── rootReducer.ts        -> Reducers are combined here
 │   ├── routes.tsx            -> Routes
 │   └── store.ts              -> Redux store configurations
 ├─> components                -> "Dumb" components, do not usually subscribe to Redux state
 │   └── SuspenseFallback.tsx  -> Fallback component for lazy routes
 ├─> containers                -> Smart components (containers, views, screens...), routes usually point to these, subscribe to Redux state
 │   └── ObjectsContainer.tsx  -> Example container
 ├─> ducks                     -> Ducks reducer bundles
 │   ├── objectsDuck.ts        -> Example of a autogenerated REST "objects" duck
 │   └── restDuckGenerator.ts  -> Duck generator function for REST resources
 ├─> templates                 -> Templates (if you use Oauth/OpenID Connect, then you'll probably need another one for token silent renewal)
 │   └── index.html            -> The template where the app is rendered
 └─> utils                     -> Utilities
     └── restDuckGenerator.ts  -> Duck generator function for REST resources
```

## Utilities

The template is heavily targeted towards projects which use RESTful APIs as their backends. Due to this, there is a generic reducer / action generator which is able to generate Redux reducer bundles, [Ducks](https://github.com/erikras/ducks-modular-redux), automatically for given endpoint. This reduces the usual heavy Redux boilerplate code to minimum. The generator utilizes [Redux Toolkit](https://redux-toolkit.js.org/).

For example, the Redux config (including basic selectors) for "objects" endpoint for the https://restful-api.dev/ API looks like this when utilizing the generator:

```Typescript
import createRestDuck from './restDuckGenerator';
import { RootState } from '../app/store';

export interface Data {
  color: string;
  capacity: string;
}

export interface Object {
  id: string;
  name: string;
  data: Data;
}

const { reducer, adapter, actions } = createRestDuck<Object>('objects');

export const {
  selectById: selectObjectById,
  selectIds: selectObjectIds,
  selectEntities: selectObjectEntities,
  selectAll: selectAllObjects,
  selectTotal: selectTotalObjects
} = adapter.getSelectors((state: RootState) => state.objects);

export { reducer, actions, adapter };

```

This will create the state structure for objects:

```Typescript
{
  ids: (number | string)[], // id's of the objects in the entities dictionary
  entities: Dictionary<Object>, // actual Object entities
  // status flags for async actions
  isFetchingOne: boolean,
  isFetchingMany: boolean,
  isUpdating: boolean,
  isDeleting: boolean,
  isCreating: boolean
}
```

The state shape is normalized. Without normalization the state would be very complex and unmanageable. Normalized state is also highly recommended by official [Redux docs](https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape). The `ids` list and `entities` dictionary come from Redux Toolkit's [createEntityAdapter](https://redux-toolkit.js.org/api/createEntityAdapter).

Using the autogenerated async action creators:

```Typescript
import { actions as objectActions } from "../ducks/objectsDuck";

dispatch(objectActions.get()) // or with params dispatch(objectActions.get("queryParam=value"))
dispatch(objectActions.getOne(1))
dispatch(objectActions.create(object))
dispatch(objectActions.update(1, object))
dispatch(objectActions.remove(1))
```

The utility generator should be used for interfacing with REST resources. If you need some other global state to Redux, it's recommended to follow the Ducks-pattern to add some custom reducers and actions (duck bundles / state slices) with the help of the Redux Toolkit.

In some cases, some components might need direct interfacing with an API in the component itself. In these cases, the API call is usually some operation that does not affect the global state.

## REST API structure and API design considerations

This project expects that the REST API follows certain structure which is often considered as the "best practice". In the following examples you can replace "resources" with any possible entity you can come up with (objects, cars, vehicles, devices etc.).

The top level of the returned JSON payload could have following structure which is currently used in the template (you can extend or change this, just edit `api/index.ts` according to your API payload structure):

The API endpoints should be built like this:

```
- GET /resources -> returns a list of resources
- GET /resources/{id} -> returns the resource which matches the id
- POST /resources -> creates a new resource based on the supplied payload, returns the new resource
- PUT /resources/{id} -> updates the resource which matches the id with the new values given in the payload, returns the updated resource
- DELETE /resources/{id} -> deletes the resource which matches the id
```
